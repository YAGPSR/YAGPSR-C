#include "headers.h"

ClFarrowFilter::ClFarrowFilter()
{
	K = 3;
	set_coefficients();
}

ClFarrowFilter::ClFarrowFilter(const int &iK)
{
	K = iK;
	set_coefficients();
}

void ClFarrowFilter::initialize(const int &iK)
{
	K = iK;
	set_coefficients();
}


/*
* Generate the interpolation coefficients for use with the interpolator where they have not previously been calculated
* Hard-coded for a K = 3 Lagrange interpolation
*/
void ClFarrowFilter::set_coefficients()
{
	if (K == 3)
	{
		c.resize(0);
		c.reserve(16);
		c.push_back(-1.0 / 6.0);
		c.push_back(0.5);
		c.push_back(-0.5);
		c.push_back(1.0 / 6.0);
		c.push_back(0.5);
		c.push_back(-1.0);
		c.push_back(0.5);
		c.push_back(0.0);
		c.push_back(-1.0 / 3.0);
		c.push_back(-0.5);
		c.push_back(1.0);
		c.push_back(-1.0 / 6.0);
		c.push_back(0.0);
		c.push_back(1.0);
		c.push_back(0.0);
		c.push_back(0.0);
	}
	else if (K == 5)
	{
		c.resize(0);
		c.reserve(36);
		c.push_back(  -1.0 / 120.0);
		c.push_back(   5.0 / 120.0);
		c.push_back( -10.0 / 120.0);
		c.push_back(  10.0 / 120.0);
		c.push_back(  -5.0 / 120.0);
		c.push_back(   1.0 / 120.0);
		c.push_back(   5.0 / 120.0);
		c.push_back( -20.0 / 120.0);
		c.push_back(  30.0 / 120.0);
		c.push_back( -20.0 / 120.0);
		c.push_back(   5.0 / 120.0);
		c.push_back(   0.0);
		c.push_back(  -5.0 / 120.0);
		c.push_back(  -5.0 / 120.0);
		c.push_back(  50.0 / 120.0);
		c.push_back( -70.0 / 120.0);
		c.push_back(  35.0 / 120.0);
		c.push_back(  -5.0 / 120.0);
		c.push_back(  -5.0 / 120.0);
		c.push_back(  80.0 / 120.0);
		c.push_back(-150.0 / 120.0);
		c.push_back(  80.0 / 120.0);
		c.push_back(  -5.0 / 120.0);
		c.push_back(   0.0);
		c.push_back(   6.0 / 120.0);
		c.push_back( -60.0 / 120.0);
		c.push_back( -40.0 / 120.0);
		c.push_back( 120.0 / 120.0);
		c.push_back( -30.0 / 120.0);
		c.push_back(   4.0 / 120.0);
		c.push_back(   0.0);
		c.push_back(   0.0);
		c.push_back( 120.0 / 120.0);
		c.push_back(   0.0);
		c.push_back(   0.0);
		c.push_back(   0.0);
	}
	else
	{
		fprintf(stderr, "Farrow Filter: Invalid K (only K=3 and K=5 are currently supported)"); fflush(stderr);
		exit(1);
	}
}


// round is not implemented in the compiler being used, comment out if using a compiler which supports the round function
inline double round(const double &x)
{
	return(floor(x + 0.5));
}

unsigned ClFarrowFilter::get_K()
{
	return(K);
}


/*
* Interpolation using the Farrow structure
* Takes as input the Farrow appropriate interpolation coefficients (e.g. generated by lagrange_basis_polynomial.m) and 
* the interpolation point, mu, 0 \le me \le 1, the actual interpolation point is dependent on the order of the polynomials used.
*/

template void ClFarrowFilter::interpolate(std::vector<std::complex<double>> *const, std::vector<std::complex<double>> const &, vdouble_t const &);
template void ClFarrowFilter::interpolate(std::vector<double> *const, std::vector<double>  const &, vdouble_t const &);
template<typename T>
void ClFarrowFilter::interpolate(std::vector<T> *const y, std::vector<T> const &x, vdouble_t const &p)
{
	vint_t    interp_ref;
	vdouble_t mu;
	vint_t    v;

	int       fK2;

	// The interpolation parameters
	interp_ref.resize(p.size());
	mu.resize(p.size());

	// The output vector, no need to initialize values as all values are overwritten
	y->resize(p.size());

	// K is a positive integer so this performs floor(K/2.0)
	fK2 = K / 2;

	for (size_t n = 0; n < p.size(); n++)
	{
		interp_ref[n] = (int)floor(p[n]);
		mu[n]         = p[n] - interp_ref[n];
	}

	for (size_t n = 0; n < p.size(); n++)
	{
		double mu_tap;
		T      sum, acc;

		sum    = 0;
		mu_tap = 1.0;
		for (int k = K; k >= 0; k--)
		{
			acc = 0;
			for (int s = 0; s < K + 1; s++) 
			{
				acc += x[interp_ref[n] - fK2 + s - 1] * c[(K + 1) * k + s];
			}

			sum    += mu_tap * acc;
			mu_tap *= mu[n];
		}
		(*y)[n] = sum;
	}
}
